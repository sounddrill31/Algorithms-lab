name: Compile C and Create Releases

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      buildall:
        description: 'Set to true to build all .c files in the repository'
        required: false
        type: boolean
        default: false

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Get changed files
      id: changed-files
      if: ${{ github.event_name != 'workflow_dispatch' || !inputs.buildall }}
      uses: tj-actions/changed-files@v46
      with:
        files: '**/*.c' # Only consider C files

    - name: Get all C files (if building all)
      id: all-c-files
      if: ${{ github.event_name == 'workflow_dispatch' && inputs.buildall }}
      run: |
        # Collect all C file paths and join them into a single space-separated string
        all_c_files=$(find . -name "*.c" -print | sed 's/^\.\///' | tr '\n' ' ')
        # Set the output variable
        echo "files=$all_c_files" >> "$GITHUB_OUTPUT"

    - name: Compile and release
      run: |
        # Determine the list of files to compile
        files_to_compile=""
        if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.buildall }}" == "true" ]]; then
          # Trim leading "./" from file paths if necessary
          files_to_compile=$(find . -name "*.c" -print | sed 's/^\.\///')
        else
          files_to_compile="${{ steps.changed-files.outputs.modified_files }} ${{ steps.changed-files.outputs.added_files }}"
        fi

        for file in $files_to_compile; do
          if [[ -z "$file" ]]; then
            continue # Skip empty entries
          fi

          filename=$(basename "$file" .c)
          binary_name="$filename"
          
          # Compile the C file with verbose output and error handling
          if ! gcc -Wall -Wextra -g "$file" -o "$binary_name"; then
            echo "Error: Compilation failed for $file. Check the logs for details."
            exit 1
          fi
          
          # Create a release based on the filename and tag
          release_title=$(echo "$filename" | sed -E 's/(.*)-(.*)-(.*)/\u\1 \u\2 (\u\3)/g' | sed 's/-/ /g')

          existing_release=$(gh release view "$filename" --json id,url -q '{"id":.id,"url":.url}' 2>/dev/null)

          if [ -z "$existing_release" ]; then
            gh release create "$filename" \
              --title "$release_title" \
              --notes "Compiled binary for $file" \
              "$binary_name"
          else
            echo "Release with tag '$filename' already exists. Skipping upload to avoid overwriting. Consider using --clobber if overwriting is desired." 
          fi
        done
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
